<!--
Solu√ß√£o hybrid mais robusta: Use uma collection simples criada via c√≥digo:// Crie a collection programaticamente uma vez
const databases = new Appwrite.Databases(client);

// Isso s√≥ precisa rodar uma vez para criar a structure
async function setupDatabase() {
    try {
        await databases.createCollection(
            'database_id', 
            'progress_collection',
            'User Progress'
        );
        
        // Adicionar atributos
        await databases.createStringAttribute('database_id', 'progress_collection', 'user_id', 255, true);
        await databases.createStringAttribute('database_id', 'progress_collection', 'lesson_name', 255, true);
        // ... outros atributos
    } catch (error) {
        console.log('Collection j√° existe ou erro:', error);
    }
}
Lembre-se de que frases.length precisa estar dispon√≠vel no escopo onde esta l√≥gica √© executada. Certifique-se de que o carregamento do SRT (que popula frases) ocorra antes ou que frases seja populado de alguma forma antes desta verifica√ß√£o, caso contr√°rio, frases.length pode ser 0 ou indefinido. A estrutura atual do seu c√≥digo parece carregar o SRT dentro de loadLesson, o que significa que frases.lengthda lastLessonIndex antes de exibir o confirm.Uma abordagem mais robusta seria carregar o SRT da √∫ltima li√ß√£o em segundo plano para obter o frases.length antes de exibir a confirma√ß√£o, ou ajustar a mensagem para n√£o incluir o total de frases se essa informa√ß√£o n√£o estiver prontamente dispon√≠vel. Para manter a simplicidade e seguir sua instru√ß√£o de ajustar as fun√ß√µes existentes, a solu√ß√£o proposta assume que voc√™ ajustar√° a exibi√ß√£o se frases.length n√£o for o esperado no momento da confirma√ß√£o. No entanto, a forma mais segura seria carregar o SRT da li√ß√£o para obter o frases.length antes de exibir a confirma√ß√£o. Isso pode exigir uma refatora√ß√£o maior do que um simples ajuste. Para o prop√≥sito de unificar as confirma√ß√µes, o c√≥digo acima atende ao seu pedido, mas a exibi√ß√£o de frases.length pode ser imprecisa se o SRT ainda n√£o tiver sido carregado para aquela li√ß√£o espec√≠fica.
Problemas e Solu√ß√µes
Vari√°veis n√£o declaradas:
A vari√°vel btnSignupHeader estava sendo referenciada, mas n√£o havia um elemento HTML com o ID btnSignup no seu c√≥digo. A corre√ß√£o foi ajustar a refer√™ncia para id="btnLogin" que √© o ID correto do bot√£o "Cadastrar".
A vari√°vel userEmailDisplay tamb√©m n√£o tinha um elemento correspondente. Adicionei um <span> com o ID user-email-display no cabe√ßalho do menu para exibir o e-mail do usu√°rio logado.
L√≥gica da fun√ß√£o renderUIForAuthState:
A fun√ß√£o tentava manipular userEmailDisplay, que n√£o existia. Isso causava um erro no console. A solu√ß√£o foi a adi√ß√£o do elemento HTML e a corre√ß√£o da l√≥gica para exibir o e-mail e os bot√µes de login/logout/cadastro corretamente.
A fun√ß√£o n√£o estava escondendo os bot√µes de login/cadastro quando o usu√°rio estava logado, o que causava uma duplicidade na interface. A corre√ß√£o garante que os bot√µes corretos (Entrar e Cadastrar) sejam exibidos apenas quando o usu√°rio n√£o estiver autenticado, e o bot√£o de Sair seja exibido somente quando ele estiver.
L√≥gica da fun√ß√£o showSection:
A fun√ß√£o showSection recebia um par√¢metro 'main', mas n√£o havia uma se√ß√£o com esse ID. Isso causava um erro de execu√ß√£o. A corre√ß√£o foi remover a refer√™ncia a 'main' e garantir que a fun√ß√£o apenas mostre as telas de autentica√ß√£o (login, signup, recover, user). Como a tela principal do jogo √© o padr√£o, n√£o √© necess√°rio uma fun√ß√£o espec√≠fica para exibi-la.
Integra√ß√£o do menu de autentica√ß√£o com o menu principal:
O clique nos bot√µes btnLogin e btnSignup no cabe√ßalho do menu n√£o fechava a tela principal do menu (menu-overlay), fazendo com que as telas de login/cadastro fossem exibidas sobre a lista de li√ß√µes. A solu√ß√£o foi criar a fun√ß√£o hideMenuContent para esconder os elementos internos do menu (menu-mode, menu-items, menu-header) antes de exibir a tela de autentica√ß√£o, e a fun√ß√£o toggleMenu para lidar com a abertura e fechamento completo do menu.
Vari√°veis e L√≥gica da fun√ß√£o clicarPalavra:
A vari√°vel palavrasDisponiveisElementos n√£o estava sendo populada corretamente. A corre√ß√£o foi inicializ√°-la como um array vazio e preench√™-la dentro da fun√ß√£o criarPalavras com todos os elementos <div> das palavras dispon√≠veis, garantindo que o bot√£o "Passar" e a fun√ß√£o de autocompletar a √∫ltima palavra funcionem.
A vari√°vel currentUtterance estava sendo usada de forma inconsistente, causando problemas no encadeamento das pron√∫ncias. A corre√ß√£o garante que uma √∫nica refer√™ncia seja usada para cada "palavra" falada, permitindo que a pr√≥xima a√ß√£o (a pr√≥xima pron√∫ncia ou o avan√ßo da frase) seja corretamente agendada no evento onend.
Fun√ß√£o processAndAdvancePhrase:
A chamada para switchActiveClock() estava sendo feita para um √≠ndice de frase que poderia estar fora do array (frases.length). A corre√ß√£o adiciona uma verifica√ß√£o para garantir que o rel√≥gio s√≥ mude se houver uma pr√≥xima frase para ser jogada.
Fun√ß√£o desistir (Passar):
A l√≥gica para encontrar o elemento correto a ser revelado estava falhando. A corre√ß√£o foi otimizar a busca pelo elemento, garantindo que ele n√£o tenha a classe acertada.
A l√≥gica para autocompletar a √∫ltima palavra na fun√ß√£o "desistir" foi unificada com a da fun√ß√£o clicarPalavra, tornando o c√≥digo mais robusto.
Reorganiza√ß√£o e Otimiza√ß√£o:
As vari√°veis de sele√ß√£o de elementos HTML foram movidas para o in√≠cio do bloco de autentica√ß√£o para melhor organiza√ß√£o.
Adicionei a chamada √† fun√ß√£o checkAuthStatus() na inicializa√ß√£o do script para verificar o estado de login do usu√°rio assim que a p√°gina carregar.
Adicionei a vari√°vel audioPlaying para controlar o estado do sintetizador de voz e evitar problemas de √°udio sobreposto.
Adicionei a vari√°vel playerReady para lidar com a assincronia do carregamento do v√≠deo e do arquivo de legenda. Isso garante que o jogo possa
-->
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhraseCraft</title>

    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Roboto+Mono:wght@400;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&display:wght@400;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Cores de Fundo e Sombra */
            --background-color: #f0f0f0;
            --shadow-color: rgba(0, 0, 0, 0.3);

            /* Novos Degrad√™s */
            --blue-gradient-start: #007bff; /* Azul vibrante */
            --blue-gradient-end: #0056b3;    /* Azul mais escuro */

            --grey-gradient-start: #d0d0d0; /* Agora o 'escuro' (que era o fim) */
            --grey-gradient-end: #e0e0e0;    /* Agora o 'claro' (que era o in√≠cio) */

            --red-gradient-start: #dc3545; /* Vermelho vibrante */
            --red-gradient-end: #a71d2a;    /* Vermelho mais escuro */

            --orange-gradient-start: #ffc107; /* Laranja vibrante */
            --orange-gradient-end: #e0a800;    /* Laranja mais escuro */

            /* Vari√°veis para o progresso do JavaScript (mantidas) */
            --progress: 0; /* 0 a 100 - Controla o preenchimento pelo JS */
        }

        body {
            display: flex;
            height: 100vh;
            justify-content: center;
            align-items: flex-start;
            background: linear-gradient(-135deg, #000000, #3b0047, #660000, #000000);
            margin: 0;
            padding-top: 1.2%;
            font-family: 'Orbitron', sans-serif;
            color: #00ccff;
            text-shadow:
                0 0 15px rgba(0, 204, 255, 0.7), /* Tom da cor base mais claro */
                0 0 25px rgba(0, 220, 255, 0.5), /* Um pouco mais claro e difuso */
                0 0 35px rgba(0, 235, 255, 0.3); /* Mais claro e ainda mais difuso */
            letter-spacing: 1.5px;
            overflow: hidden;
        }

        .control-button {
            padding: 10px 15px;
            background: linear-gradient(to bottom, #5cbc5c 0%, #4CAF50 50%, #45a049 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            text-shadow: 0 1px 1px rgba(0,0,0,0.1);
            transition: all 0.3s cubic-bezier(.25,.8,.25,1);
        }

        .control-button:hover {
            background: linear-gradient(to bottom, #6ad26a 0%, #5cbc5c 50%, #4CAF50 100%);
            box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
            transform: translateY(-1px);
        }

        .control-button:active {
            background: linear-gradient(to bottom, #45a049 0%, #4CAF50 50%, #5cbc5c 100%);
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
            transform: translateY(1px);
        }
	    
        #menu-button {
            margin-top: -5%;
            background: transparent;
            text-decoration: none;
            color: #14fff1;
            border: 0px solid #14fff1;
            border-radius: 6px; /* Keep your existing border-radius */
            box-shadow:
                0px 0px 16px rgba(0, 0, 0, 0.6), /* Existing outer shadow */
                /* Inner bottom glow - Adjust these values for the "egg tip" shape */
                inset 0px -5px 6px -5px rgba(0, 204, 255, 0.7), /* Base inner glow */
                inset 0px -7px 6px -8px rgba(0, 220, 255, 0.5), /* Lighter, more diffuse */
                inset 0px -10px 6px -10px rgba(0, 235, 255, 0.3); /* Lightest, most diffuse */
            transition: transform 0.15s ease-out, box-shadow 0.15s ease-out; /* Added box-shadow transition too */
            font-family: 'Audiowide', sans-serif; /* Apply the font */
            font-size: 0.65em;
            letter-spacing: 0.2em; /* Optional: adds a slight space between letters for a techy look */
            text-transform: uppercase; /* Optional: makes text uppercase, common in futuristic UIs */
        }

        #menu-button:hover {
            box-shadow:
                0px 0px 16px rgba(0, 0, 0, 0.6), /* Existing outer shadow */
                inset 0px -5px 6px -5px rgba(0, 204, 255, 0.7),
                inset 0px -7px 6px -8px rgba(0, 220, 255, 0.5),
                inset 0px -10px 6px -10px rgba(0, 235, 255, 0.3);
            transform: translateY(-1px); /* Lifts up slightly on hover */
        }

        #menu-button:active {
            box-shadow:
                0px 0px 8px rgba(0, 0, 0, 0.8), /* outer shadow darker/more intense when pressed */
                inset 0px 0px 3px rgba(0, 204, 255, 0.9), /* inner glow when pressed */
                inset 0px 0px 5px rgba(0, 220, 255, 0.7); /* inner glow for depth */
            transform: translateY(2px); /* Moves down when clicked */
            background-color: transparent; /* Keep background transparent */
        }

        #menu-overlay {
            position: fixed;
            top: 0; /* Changed from 1% for full top alignment */
            right: 0; /* Changed from 1% for full right alignment */
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.8);
            font-family: 'Audiowide', sans-serif;
            z-index: 999;
            display: flex; /* Enable Flexbox */
            flex-direction: column; /* Stack items vertically (close-button above menu-items) */
            align-items: center; /* This centers items horizontally in a column layout */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            backdrop-filter: blur(8px);
        }

        #menu-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        #menu-items {

        }

        .menu-title {
            text-align: center;
            color: #f9fff2;
            font-size: 22px;
            margin-bottom: 18px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Audiowide', sans-serif; /* Apply the font */
            letter-spacing: 0.05em; /* Optional: adds a slight space between letters for a techy look */
            text-transform: uppercase; /* Optional: makes text uppercase, common in futuristic UIs */
        }

        .lesson-button, .mode-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            text-align: left;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .lesson-button:hover, .mode-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 14px rgba(0,0,0,0.2);
        }

        .lesson-button:after, .mode-button:after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(120deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);
            transform: translateX(-100%);
            transition: all 0.6s ease;
        }

        .lesson-button:hover:after, .mode-button:hover:after {
            transform: translateX(100%);
        }

    	/* New CSS for the header row containing 'Ajuda' and the close button */
    	.menu-header {
    		display: flex;
    		justify-content: space-between;
    		align-items: center;
    		width: 100%;
    		padding: 10px 20px;
    		box-sizing: border-box;
    	}
            
    		/* Ajustes para o bot√£o "Voltar" */
    		.back-button, #info {
    		    background: grey;
            color: white;
    		    border-radius: 8px;
    		    padding: 10px;
    		    flex-shrink: 0;
    		    /* Remover margin-right: auto; daqui se estiver, n√£o √© necess√°rio com justify-content: space-between */
    		}

        .back-button:hover {
            background: rgba(255, 255, 255, 0.4);
        }
		/* menu footer */
		.menu-footer {
            display: flex; /* Inicialmente oculto */
            justify-content: space-between;
            padding: 15px 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: auto;
        }
        
        .footer-btn {
            flex: 1;
            padding: 10px;
            margin: 0 5px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .footer-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border-color: #4ecdc4;
            color: #000;
            font-weight: bold;
        }
        
        .footer-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .footer-btn.active:hover {
            background: linear-gradient(45deg, #5ed3ca, #4bc4e2);
        }
        
        /* Estilos para div de Entrar e Cadastrar */
        .user-buttons button {
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            font: inherit;
            color: #00ccff;
            cursor: pointer;
            text-decoration: underline;
        }
        
        .user-buttons button:hover {
            color: darkblue;
        }

        /**/
        /* --- Login Screen Container Styles --- */
        .login-screen-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            opacity: 1;
            transition: opacity 0.5s ease;
            z-index: 2000;
        }

        .login-screen-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* --- Login Card Styles --- */
        .login-card {
            background: #1a1a2e;
            border-radius: 15px;
            padding: 30px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: scale(1);
            animation: loginCardAppear 0.3s ease-out;
        }

        @keyframes loginCardAppear {
            from {
                transform: scale(0.9);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #fff;
            font-size: 1.5em;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .close-button:hover {
            transform: rotate(90deg);
        }

        .login-card h2 {
            font-size: 2em;
            margin-bottom: 25px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .login-card input {
            width: 90%;
            padding: 15px;
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .login-card input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .login-card input:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }

        .btnLogin {
            width: 50%;
            padding: 15px;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            border-radius: 8px;
            color: #0a0a0a;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btnLogin:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(69, 183, 209, 0.4);
        }

        .login-card p {
            font-size: 0.9em;
            margin-top: 15px;
            color: rgba(255, 255, 255, 0.7);
        }

        .login-card a {
            color: #4ecdc4;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .login-card a:hover {
            color: #ff6b6b;
            text-decoration: underline;
        }
        /**/

        /* Loading Indicator */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
        }

        #loading.active {
            visibility: visible;
            opacity: 1;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-radius: 50%;
            border-top: 5px solid #3498db;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Current lesson info */
        #current-lesson {
            text-align: center;
            color: #f9fff2;
            margin-top: 5px;
            font-size: 16px;
            font-weight: bold;
        }
		
        #subtitle-content {
            margin-top: 20px;
            padding: 25px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
            min-height: 100px;
            text-align: left;
            font-size: 1.1em;
            color: #555;
            transition: opacity 0.5s ease-in-out; /* Transi√ß√£o para o efeito de "sumir" */
            line-height: 1.6;
        }

        #subtitle-content.hidden {
            opacity: 0; /* Torna o conte√∫do invis√≠vel */
            max-height: 0; /* Colapsa o espa√ßo ocupado */
            overflow: hidden;
            padding: 0 25px; /* Remove padding quando oculto */
            border: none; /* Remove a borda quando oculto */
        }
        
        /* ==========
        // Containers
        // ========== */
        .main-container {
            background-image: linear-gradient(-135deg, #171627, #111d4a, #171627, #111d4a);
            background-color: #171627;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            text-align: center;
            width: 90%;
            max-width: 600px;
            padding: 10px;
            display: flex; /* Make main-container a flex container */
            flex-direction: column; /* Stack children vertically */
            gap: 5px; /* MUDAN√áA: Reduzido de 10px para 5px */
            justify-content: flex-start;
            align-items: center;
            animation: fadeInScale 1s ease-out;
        }

        .title-container {
            text-align: center;
        }

        .content-row {
            display: flex;
            flex-direction: row;
            margin-top: 1%;
            gap: 10px;
            align-items: center; /* ‚Üê MUDAN√áA: centraliza verticalmente */
            justify-content: center; /* ‚Üê ADICIONE: centraliza horizontalmente */
            width: 96%;
            flex-wrap: nowrap;
            overflow: hidden;
            min-height: 180px; /* ‚Üê ADICIONE: altura m√≠nima para melhor centraliza√ß√£o */
        }
        
        /* Ajustes para o container do v√≠deo */
        .content-row .video-container {
            flex: 1 1 70%;
            min-width: 0;
            max-width: 80%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* ADICIONE ISSO: Torna este o cont√™iner de posicionamento para o filho absoluto */
        }

        /* O container do v√≠deo onde o player e a legenda ficam */
        .video-container #custom-video {
            /* Mantenha suas propriedades de tamanho para o v√≠deo em si */
            width: 100%; /* MUDAN√áA: Use 100% para preencher o pai */
            height: auto; /* MUDAN√áA: Use auto para manter o aspect ratio original do v√≠deo */
            aspect-ratio: 16/9; /* Mantenha isso para garantir a propor√ß√£o do v√≠deo */
            display: block; /* Garante que n√£o haja espa√ßo extra abaixo do v√≠deo */
            background-color: #000;
            border: none;
        }

    		/* Estilos para o conte√∫do da legenda que aparecer√° sobre o v√≠deo */
    		#subtitle-content {
            position: absolute;
            width: 95%;
            height: auto;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            text-align: center;
            font-size: 1.0em;
            box-sizing: border-box;
            z-index: 10;
            top: 50%; /* Moves the top edge of the element to the middle of its parent */
            transform: translateY(-50%); /* Shifts the element up by half of its own height */
        }
		
    		/* Classe para ocultar o conte√∫do da legenda */
    		#subtitle-content.hidden {
    		    display: none;
    		}
        
        /* Ajustes para os bot√µes */
        .content-row #buttons {
            flex: 1 1 40%;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center; /* ‚Üê MUDAN√áA: centraliza bot√µes horizontalmente */
            justify-content: center; /* ‚Üê ADICIONE: centraliza bot√µes verticalmente */
            min-width: 0;
            max-width: 40%;
            padding: 0; /* ‚Üê MUDAN√áA: remove padding-top */
        }
        
        /* Opcional: Para garantir que os bot√µes tenham largura consistente */
        .content-row #buttons button {
            width: 100%;
            max-width: 200px; /* ‚Üê ADICIONE: largura m√°xima para os bot√µes */
            padding: 10px;
            border: none;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }

        p {
            margin: 10px 0;
            color: #666;
        }
        
        .phrase-container {
            font-size: 24px;
            width: 95%;
            min-height: 60px;
            border: 1px dashed #a5b68f;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            word-break: break-word;
            background-color: #f9fff2;
            color: #333;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .palavra-na-frase { /* Added style for words in the displayed phrase */
            margin-right: 1.2%;
            color: #0056b3; /* A distinct color for correctly placed words */
            border: 1px solid #ccc; 
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .word-button-wrapper {
            width: 100%; /* Ensures the wrapper takes full available width */
            display: flex; /* Keeping it flex allows for easy centering of its children */
            flex-direction: column; /* Stack children vertically */
            align-items: center; /* Center children horizontally */
            gap: 10px; /* Adjust gap as needed for spacing between word container and button */
        }

        .word-container {
            flex-wrap: wrap;
            width: 95%;
            border: none;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            padding: 10px;
        }

        .palavra { 
            background-color: #007bff;
            color: white;
            padding: 2px 5px; /* Change this line */
            margin: 5px; /* Added margin for spacing between words */
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease, background-color 0.2s ease;
            user-select: none; /* Impede sele√ß√£o de texto */
        }

        .palavra.selecionada {
            background: linear-gradient(to bottom, #ffc107, #e0a800); /* Um gradiente laranja para destaque */
            transform: translateY(-2px); /* Efeito de eleva√ß√£o */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); /* Sombra mais forte */
        }

        .palavra.errada { /* Corrected class name */
            animation: shake 0.4s ease-in-out;
            background-color: #dc3545; /* Vermelho */
        }

        .palavra.acertada {
            background-color: #28a745; /* Green for correct words */
            pointer-events: none; /* Disable clicks on already correct words */
        }

      	.palavra.no-click {
      	    pointer-events: none; /* Impede que o mouse interaja com o elemento */
      	    opacity: 0.6;        /* Torna um pouco transparente para indicar desativa√ß√£o */
      	    cursor: default;     /* Muda o cursor para indicar que n√£o √© clic√°vel */
      	}

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }

        .players-container {
            position: relative;
            display: flex;
            justify-content: center;
            gap: 10px;
            width: 100%; /* ‚Üê MUDAN√áA: garante que n√£o exceda o container pai */
            max-width: 100%; /* ‚Üê ADICIONE: for√ßa limita√ß√£o */
            margin: 0 auto;      /* Center it horizontally */
        }

        .player-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
        }

        .player-container,
        .title-container {
            flex: 1; /* Ocupa partes iguais */
            display: flex;
            flex-direction: column;
            align-items: center; /* ‚Üê Centraliza horizontalmente */
        }

        .player-content {
            position: relative;
            width: 70px;
            height: 70px;
            background: linear-gradient(-135deg, #000000, #3b0047, #660000, #000000);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transform: translateY(calc((85px - 70px) / 2));
        }

        .player-content h6 {
            margin: 0; /* Remove default margins from h6 and p for tighter control */
            margin-bottom: 0.4em;
            padding-top: 0.4em;
            line-height: 1.6em; /* Adjust line height if needed */
            font-size: 0.7em; /* Adjust font size if too large */
        }

        .clock-face {
            position: absolute;
            width: 85px;
            height: 85px;
            background: linear-gradient(135deg, var(--blue-gradient-start), var(--blue-gradient-end));
            border-radius: 15px;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            align-items: flex-start;
            transition: background 0.7s ease-in-out;
        }

        /* Onde a magia do preenchimento circular acontece (sempre cinza) */
        .clock-face::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px;
            /* A cor de preenchimento SEMPRE ser√° cinza */
            background: conic-gradient(
                var(--grey-gradient-start) calc(var(--progress) * 1%),
                var(--grey-gradient-end) calc(var(--progress) * 1% + 1%),
                transparent calc(var(--progress) * 1% + 1%)
            );
            transform: rotate(-0deg);
            transform-origin: center;
            transition: background 0.1s linear; /* Transi√ß√£o suave para o preenchimento */
        }

        /* Estilo para quando o tempo estiver nos 30% finais (ativado pelo JavaScript) */
        .clock-face.time-almost-up {
            /* O fundo do clock-face agora piscar√° com esta anima√ß√£o */
            animation: blink-red-to-orange 1s infinite alternate;
        }

        /* Anima√ß√£o para o piscar de vermelho degrad√™ para laranja degrad√™ NO FUNDO DO CLOCK-FACE */
        @keyframes blink-red-to-orange {
            0%, 100% {
                background: linear-gradient(135deg, var(--red-gradient-start), var(--red-gradient-end));
            }
            50% {
                background: linear-gradient(135deg, var(--orange-gradient-start), var(--orange-gradient-end));
            }
        }
    </style>
</head>
<body>
    <div class="main-container">

        <div id="menu-overlay">        
            <div class="menu-header" id="menu-header">
                <button class="back-button">‚¨ÖÔ∏è</button>
                <button id="info" class="">Ajuda</button>
                <div class="user-buttons">
                    <button id="btnLogin">Entrar</button>
                    <button id="btnSignup">Cadastrar</button>
                    <div id="user-email-display" style="font-size: 0.9em; color: rgba(255, 255, 255, 0.7);"></div>
                    <button id="btnLogout" class="">Sair</button>
                </div>
            </div>
            
            <div id="menu-mode">
                <h2 class="menu-title">Selecione o Modo de Jogo</h2>                
                <button class="mode-button" onclick="currentMode('solo')">Solo</button>
                <button class="mode-button" onclick="currentMode('multi')">Multiplayer</button>
            </div>  
            
            <div id="menu-items">
                <h2 class="menu-title">Lista de Li√ß√µes</h2>
                
                <!-- Card Continuar (s√≥ aparece se h√° progresso na categoria atual) -->
                <div id="continue-card" class="continue-card hidden">
                    <div class="continue-header"></div>
                    <div class="continue-lesson-name" id="continue-lesson-name">Lady Gaga - Schei√üe</div>
                    <div class="continue-progress" id="continue-progress">Frase 15 de 45 ‚Ä¢ √öltima sess√£o: h√° 2 dias</div>
                    <button class="footer-btn" id="continue-button"> ‚è© Continuar</button>
                </div>
            
                <!-- Lista de li√ß√µes ser√° populada dinamicamente aqui -->
                <div id="lessons-list"></div>
            
                <!-- Footer de navega√ß√£o -->
                <div class="menu-footer" id="menu-footer">
                    <button class="footer-btn" id="search-btn">
                        <span class="search-icon">üîç</span>
                        <span class="btn-text">Buscar</span>
                    </button>
                    <button class="footer-btn active" id="avulsas-btn">Avulsas</button>
                    <button class="footer-btn" id="trilhas-btn">Trilhas</button>
                </div>
            
                <!-- Footer em modo busca (inicialmente oculto) -->
                <div class="search-footer hidden" id="search-footer">
                    <input type="text" class="search-input" id="search-input" placeholder="Pesquisar li√ß√µes...">
                    <button class="filter-btn" id="filter-btn" title="Filtros">‚öôÔ∏è</button>
                    <button class="close-search-btn" id="close-search-btn">‚úï</button>
                </div>
            </div>
            
            <!-- Bloco Auth -| Start -->
            <section id="login-screen" class="login-screen-container hidden">
                <div class="login-card">
                    <button class="close-button" id="btnCloseLogin">‚úï</button>
                    <h2>Entrar</h2>
                    <form id="login-form">
                        <input type="email" id="email-login" placeholder="E-mail" required>
                        <input type="password" id="password-login" placeholder="Senha" required>
                        <p id="login-message"></p>
                        <button type="submit" class="btnLogin">Entrar</button>
                    </form>
                    <p>Esqueceu a senha? <a href="#" id="link-to-recover">Recuperar</a></p>
                    <hr style="border: none; border-top: 1px solid rgba(255, 255, 255, 0.1); margin: 20px 0;">
                    <p>N√£o tem uma conta? <a href="#" id="link-to-signup">Cadastre-se</a></p>
                </div>
            </section>
        
            <section id="signup-screen" class="login-screen-container hidden">
                <div class="login-card">
                    <button class="close-button" id="btnCloseSignup">‚úï</button>
                    <h2>Cadastre-se</h2>
                    <form id="signup-form">
                        <input type="text" id="nome-signup" placeholder="Nome" required>
                        <input type="email" id="email-signup" placeholder="E-mail" required>
                        <input type="password" id="senha-signup" placeholder="Senha" required>
                        <p id="signup-message"></p>
                        <button type="submit" class="btnLogin">Cadastrar</button>
                    </form>
                    <p>J√° tem uma conta? <a href="#" id="link-to-login">Entrar</a></p>
                </div>
            </section>
        
            <section id="recover-screen" class="login-screen-container hidden">
                <div class="login-card">
                    <button class="close-button" id="btnCloseRecover">‚úï</button>
                    <h2>Recuperar Senha</h2>
                    <form id="recover-form">
                        <input type="email" id="email-recover" placeholder="E-mail" required>
                        <p id="recover-message"></p>
                        <button type="submit" class="btnLogin">Enviar</button>
                    </form>
                    <p>Lembrou da sua senha? <a href="#" id="link-to-login-from-recover">Entrar</a></p>
                    <p>N√£o tem uma conta? <a href="#" id="link-to-signup-from-recover">Cadastre-se</a></p>
                </div>
            </section>
            <!-- Bloco Auth -| End -->
        </div>

        <div id="loading">
            <div class="spinner"></div>
        </div>

        <div class="players-container">

            <div class="player-container">
                <div class="clock-face" id="clock-face1"></div>
                <div class="player-content">
                    <h6 class="score" id="placar1">0</h6>
                    <h6>Jogador 1</h6>
                </div>
            </div>

            <div class="title-container">
                <h2>Phrasecraft</h2>
                <button id="menu-button">Li√ß√µes</button>
            </div>

            <div class="player-container">
                <div class="clock-face" id="clock-face2"></div>
                <div class="player-content">
                    <h6 class="score" id="placar2">0</h6>
                    <h6>Jogador 2</h6>
                </div>
            </div>
        </div>

        <div id="current-lesson"></div>

        <div class="content-row">
            <div class="video-container">
                <video id="custom-video" class="hide-controls" preload="auto" crossorigin="anonymous">
                </video>
        
                <div id="subtitle-content" class="hidden"> 
                	<!- As legendas aparecem aqui: -->
                </div>
                
            </div>

            <div id="buttons">
                <button id="repetir" class="control-button" style="background: linear-gradient(to bottom, #b34dd6 0%, #9C27B0 50%, #7c1f8e 100%);">Tocar Trecho</button>
                <button id="lerFrase" class="control-button" style="background: linear-gradient(to bottom, #78c0ff 0%, #5babf0 50%, #4d98e5 100%);">Tocar Lento</button>
                <button id="traduzir-btn" class="control-button" style="background: linear-gradient(to bottom, #ffc078 0%, #ffa94d 50%, #e59442 100%);">Traduzir</button>
                <button id="desistir" class="control-button" style="background: linear-gradient(to bottom, #ff5e91 0%, #E91E63 50%, #c41858 100%);">Passar</button>
                
             </div>
            
        </div>

        <div class="phrase-container" id="frase">
        </div>

        <div class="word-button-wrapper">
        
            <div class="word-container" id="palavras"></div>
            
        </div>
        
        <div id="progresso" style="margin-top: 10px; font-size: 0.9em;">Progresso: 0 de 0</div>

    </div>
        
<script src="https://cdn.jsdelivr.net/npm/appwrite@18.2.0"></script>
<script>
// ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
// In√≠cio do Bloco de Atutenticacao
// ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
    
    // Configura√ß√£o do Appwrite
    const client = new Appwrite.Client()
        .setEndpoint('https://nyc.cloud.appwrite.io/v1')
        .setProject('689f3d3a00095fde3112');

    const account = new Appwrite.Account(client);

    // Seletores de elementos HTML (TODOS JUNTOS AQUI)
    const loginScreen = document.getElementById('login-screen');
    const signupScreen = document.getElementById('signup-screen');
    const recoverScreen = document.getElementById('recover-screen');
    const userScreen = document.getElementById('user-screen');

    const btnLoginHeader = document.getElementById('btnLogin');
    const btnSignupHeader = document.getElementById('btnSignup');
    const logoutButtonHeader = document.getElementById('btnLogout');

    const btnCloseLogin = document.getElementById('btnCloseLogin');
    const btnCloseSignup = document.getElementById('btnCloseSignup');
    const btnCloseRecover = document.getElementById('btnCloseRecover');

    const loginForm = document.getElementById('login-form');
    const signupForm = document.getElementById('signup-form');
    const recoverForm = document.getElementById('recover-form');
	  const userEmailDisplay = document.getElementById('user-email-display');

    const loginMessage = document.getElementById('login-message');
    const signupMessage = document.getElementById('signup-message');
    const recoverMessage = document.getElementById('recover-message');

    const linkToSignup = document.getElementById('link-to-signup');
    const linkToLogin = document.getElementById('link-to-login');
    const linkToRecover = document.getElementById('link-to-recover');
    const linkToLoginFromRecover = document.getElementById('link-to-login-from-recover');
    const linkToSignupFromRecover = document.getElementById('link-to-signup-from-recover');

¬† ¬† // Vari√°vel global para armazenar o estado anterior
¬† ¬† let previousMenuState = "modeSelection";

    /* Fun√ß√£o para renderizar a interface de
    ** acordo com o estado de autentica√ß√£o */
    function renderUIForAuthState(isLoggedIn, userEmail = '') {
        // Esconde tudo primeiro para evitar conflitos
        btnLoginHeader.style.display = 'none';
        btnSignupHeader.style.display = 'none';
        logoutButtonHeader.style.display = 'none';
        userEmailDisplay.style.display = 'none';

        if (isLoggedIn) {
            // Se o usu√°rio est√° logado, mostra o e-mail e o bot√£o de sair
            userEmailDisplay.textContent = userEmail;
            userEmailDisplay.style.display = 'block';
            logoutButtonHeader.style.display = 'block';
        } else {
            // Se o usu√°rio est√° deslogado, mostra os bot√µes de entrar e cadastrar
            btnLoginHeader.style.display = 'block';
            btnSignupHeader.style.display = 'block';
        }
    }
    
    // Fun√ß√£o para mostrar uma se√ß√£o espec√≠fica
    function showSection(section) {
        // Esconde todas as se√ß√µes primeiro
        loginScreen.classList.add('hidden');
        signupScreen.classList.add('hidden');
        recoverScreen.classList.add('hidden');
        userScreen.classList.add('hidden');
    
        // ADICIONAR ESTA L√ìGICA AQUI:
        const menuHeader = document.getElementById('menu-header');
        if (section === 'login' || section === 'signup' || section === 'recover' || section === 'user') {
            // Hide menu header para telas de autentica√ß√£o
            if (menuHeader) {
                menuHeader.style.display = 'none';
            }
        } else {
            // Show menu header para outras telas
            if (menuHeader) {
                menuHeader.style.display = 'flex';
            }
        }
        
        // Apenas mostra a se√ß√£o correta
        if (section === 'login') {
            loginScreen.classList.remove('hidden');
        } else if (section === 'signup') {
            signupScreen.classList.remove('hidden');
        } else if (section === 'recover') {
            recoverScreen.classList.remove('hidden');
        } else if (section === 'user') {
            userScreen.classList.remove('hidden');
        }
    }

    // Fun√ß√£o para verificar o status de login
    async function checkAuthStatus() {
        try {
            const user = await account.get();
            // Chama a fun√ß√£o de renderiza√ß√£o para o estado "logado"
            renderUIForAuthState(true, user.email);
            // Mostra a tela de usu√°rio logado
            // showSection('user');
        } catch (error) {
            // Chama a fun√ß√£o de renderiza√ß√£o para o estado "deslogado"
            renderUIForAuthState(false);
            // Pode ser uma tela inicial ou nada
            // showSection('main');
        }
    }
    
¬† ¬† // Eventos para abrir as modais a partir do cabe√ßalho
¬† ¬† btnLoginHeader.addEventListener('click', () => {
¬† ¬† ¬† ¬† previousMenuState = currentState; // Salva o estado atual do menu
¬† ¬† ¬† ¬† hideMenuContent();
¬† ¬† ¬† ¬† showSection('login');¬†
¬† ¬† });
¬† ¬† btnSignupHeader.addEventListener('click', () => {
¬† ¬† ¬† ¬† previousMenuState = currentState; // Salva o estado atual do menu
¬† ¬† ¬† ¬† hideMenuContent();
¬† ¬† ¬† ¬† showSection('signup');
¬† ¬† });

¬† ¬† btnCloseLogin.addEventListener('click', () => {
¬† ¬† ¬† ¬† loginScreen.classList.add('hidden');
¬† ¬† ¬† ¬† restoreMenuContent(); // Chama a nova fun√ß√£o para restaurar o menu
¬† ¬† });
¬† ¬† btnCloseSignup.addEventListener('click', () => {
¬† ¬† ¬† ¬† signupScreen.classList.add('hidden');
¬† ¬† ¬† ¬† restoreMenuContent(); // Chama a nova fun√ß√£o para restaurar o menu
¬† ¬† });
¬† ¬† btnCloseRecover.addEventListener('click', () => {
¬† ¬† ¬† ¬† recoverScreen.classList.add('hidden');
¬† ¬† ¬† ¬† restoreMenuContent(); // Chama a nova fun√ß√£o para restaurar o menu
¬† ¬† });

    // Eventos para alternar entre as telas de login, cadastro e recupera√ß√£o
    linkToSignup.addEventListener('click', (e) => {
        e.preventDefault();
        showSection('signup');
    });
    linkToLogin.addEventListener('click', (e) => {
        e.preventDefault();
        showSection('login');
    });
    linkToRecover.addEventListener('click', (e) => {
        e.preventDefault();
        showSection('recover');
    });
    linkToLoginFromRecover.addEventListener('click', (e) => {
        e.preventDefault();
        showSection('login');
    });
    linkToSignupFromRecover.addEventListener('click', (e) => {
        e.preventDefault();
        showSection('signup');
    });

    // Evento de submiss√£o do formul√°rio de login
    loginForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = document.getElementById('email-login').value;
        const password = document.getElementById('password-login').value;
        loginMessage.textContent = '';
        try {
¬† ¬† ¬† ¬† ¬† ¬† await account.createEmailPasswordSession(email, password);
¬† ¬† ¬† ¬† ¬† ¬† // Chama a fun√ß√£o que reflete o novo estado na interface
¬† ¬† ¬† ¬† ¬† ¬† checkAuthStatus();
¬† ¬† ¬† ¬† } catch (error) {
            loginMessage.textContent = 'Erro no login: ' + error.message;
        }
    });

    // Evento de submiss√£o do formul√°rio de cadastro
    signupForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const nome = document.getElementById('nome-signup').value;
        const email = document.getElementById('email-signup').value;
        const senha = document.getElementById('senha-signup').value;
        signupMessage.textContent = '';
        try {
            await account.create(Appwrite.ID.unique(), email, senha, nome);
            signupMessage.textContent = 'Usu√°rio cadastrado com sucesso! Voc√™ pode fazer login agora.';
            setTimeout(() => showSection('login'), 2000);
        } catch (error) {
            signupMessage.textContent = 'Erro ao cadastrar: ' + error.message;
        }
    });

    // Evento de submiss√£o do formul√°rio de recupera√ß√£o
    recoverForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = document.getElementById('email-recover').value;
        recoverMessage.textContent = '';
        try {
            const resetUrl = window.location.href.split('#')[0] + '#reset-password';
            await account.createRecovery(email, resetUrl);
            recoverMessage.textContent = 'Se o e-mail existir, um link de recupera√ß√£o foi enviado.';
        } catch (error) {
            recoverMessage.textContent = 'Erro ao enviar o link: ' + error.message;
        }
    });

    // Evento de clique do bot√£o de logout
    logoutButtonHeader.addEventListener('click', async () => {
¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† await account.deleteSession('current');
¬† ¬† ¬† ¬† ¬† ¬† // Chama a fun√ß√£o que reflete o novo estado na interface
¬† ¬† ¬† ¬† ¬† ¬† checkAuthStatus();
¬† ¬† ¬† ¬† } catch (error) {
            alert('Falha ao sair: ' + error.message);
        }
    });
// ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
// Fim do Bloco de Atutenticacao
// ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢

// ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
// Bloco do Banco de Dados | Inico
// ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
    const databases = new Appwrite.Databases(client);

    // Define as constantes do seu projeto
    const DATABASE_ID = '68bfc30500251b74b4fc';
    const COLLECTION_ID = '68bfc325002b09dd5ea5';

    // Fun√ß√£o para salvar o progresso do usu√°rio no localStorage
    function salvarProgresso() {
        if (!currentLessonName) return;
    
        const progressoData = {
            lessonName: currentLessonName,
            fraseIndex: indiceFrase,
            acertos1: acertos1,
            acertos2: acertos2,
            timestamp: new Date().getTime()
        };
    
        localStorage.setItem('listeningProProgresso', JSON.stringify(progressoData));
    }
    
    // Fun√ß√£o para carregar o progresso salvo
    function carregarProgresso() {
        const progressoSalvo = localStorage.getItem('listeningProProgresso');
        if (!progressoSalvo) return null;
    
        try {
            return JSON.parse(progressoSalvo);
        } catch (e) {
            console.error("Erro ao carregar progresso:", e);
            return null;
        }
    }
    
    // Fun√ß√£o para verificar se h√° progresso salvo para a li√ß√£o atual
    function verificarProgressoLicao(lessonName) {
        const progresso = carregarProgresso();
        if (!progresso || progresso.lessonName !== lessonName) return false;
    
        // Verificar se o progresso √© recente (menos de 7 dias)
        const agora = new Date().getTime();
        const diferenca = agora - progresso.timestamp;
        const diasDiferenca = diferenca / (1000 * 60 * 60 * 24);
    
        return diasDiferenca < 7;
    }
// ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
// Bloco do Banco de Dados | Fim
// ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢

//=============================
// AppData - Dados Centralizados
//=============================
const AppData = {
    lessons: {
        avulsas: [
            {
                name: "Lady Gaga - Schei√üe",
                srtFile: "Lady_Gaga-Schei√üe.srt",
                videoUrl: "https://files.catbox.moe/noor8m.mp4"
            },
            {
                name: "Melanie Martinez - The Contortionist",
                srtFile: "Melanie_Martinez-The_Contortionist.srt",
                videoUrl: "https://files.catbox.moe/vxoldg.mp4"
            },
            {
                name: "New West - Those Eyes",
                srtFile: "New_West-Those_Eyes.srt",
                videoUrl: "https://files.catbox.moe/k7xhth.mp4"
            },
            {
                name: "Skye_Riley_-_Death_Of_Me",
                srtFile: "Skye_Riley_-_Death_Of_Me.srt",
                videoUrl: "https://f005.backblazeb2.com/file/Avulsas/Skye_Riley_-_Death_Of_Me.mp4"
            }
        ], // <--- V√çRGULA ADICIONADA AQUI
        trilha: [
            {
                // Pode adicionar li√ß√µes aqui depois
            }
        ]
    }
};

// Vari√°veis globais
let videoElement = document.getElementById('custom-video');
let currentState = "modeSelection";
let menuStack = ["modeSelection"]; // Stack inicial
let frases = [];
let indiceFrase = 0;
let fraseAtual = null;
let palavrasEmbaralhadas = [];
let palavrasClicadas = [];
let palavraElementos = {};
let progresso = 0;
let acertos1 = 0;
let acertos2 = 0;
let playerReady = false;
let monitorTempoId;
let fraseAcertada = false;
let audioPlaying = false;
let currentLessonName = "";
let player1Clock; // Global variable for player 1's clock
let player2Clock; // Global variable for player 2's clock
let mostrarTraducao = false;
let palavrasDisponiveisElementos = [];

// ================================
//  Fun√ß√µes para gerenciar o stack
// ================================
function pushMenuState(newState) {
    menuStack.push(newState);
    currentState = newState;
    updateMenuDisplay();
}

function popMenuState() {
    if (menuStack.length > 1) {
        menuStack.pop();
        currentState = menuStack[menuStack.length - 1];
        updateMenuDisplay();
        return true; // Conseguiu voltar
    }
    return false; // N√£o pode voltar mais (est√° no estado inicial)
}

function updateMenuDisplay() {
    // Esconder todos os menus primeiro
    document.getElementById('menu-mode').style.display = 'none';
    document.getElementById('menu-items').style.display = 'none';
    
    // ADICIONAR ESTA LINHA:
    const menuHeader = document.getElementById('menu-header');
    
    // Mostrar o menu atual
    switch(currentState) {
        case "modeSelection":
            document.getElementById('menu-mode').style.display = 'block';
            // ADICIONAR:
            if (menuHeader) menuHeader.style.display = 'flex';
            break;
        case "lessonList":
            document.getElementById('menu-items').style.display = 'block';
            // ADICIONAR:
            if (menuHeader) menuHeader.style.display = 'flex';
            break;
    }
}

// ================================
// Fun√ß√£o para gerar o URL do CDN 
// do jsDelivr para os arquivos SRT
// ================================
function getSrtCdnUrl(filename) {
    // URL base do jsDelivr para o seu reposit√≥rio
    const baseUrl = "https://raw.githubusercontent.com/CrisClei2022/srt/main/";
    // Retorna a URL completa
    return baseUrl + encodeURIComponent(filename);
}

// Fun√ß√£o para processar o conte√∫do SRT
function processSrtContent(srt) {
    // Regex robusta para capturar os dados da legenda
    const regex = /(\d+)\r?\n(\d{2}:\d{2}:\d{2}[,.]\d{3}) --> (\d{2}:\d{2}:\d{2}[,.]\d{3})\r?\n([\s\S]*?)(?=\r?\n\r?\n|\s*$)/g;
    
    frases = []; // Limpa o array de frases antes de preencher
    let match;

    while ((match = regex.exec(srt)) !== null) {
        // Pega o texto e remove a tag de formata√ß√£o <i>...</i> e espa√ßos extras
        const textoLimpo = match[4].replace(/<i>(.*?)<\/i>/g, '$1').trim();

        // Adiciona a frase apenas se n√£o for de um anunciante
        if (textoLimpo && !textoLimpo.includes('www.RentAnAdviser.com')) {
            frases.push({
                tempoInicio: converterTempo(match[2]),
                tempoFim: converterTempo(match[3]),
                texto: textoLimpo
            });
        }
    }

    // O resto da l√≥gica da fun√ß√£o original permanece
    indiceFrase = 0;
    fraseAtual = frases[indiceFrase];
    palavrasEmbaralhadas = embaralharPalavras(fraseAtual.texto);
    palavrasClicadas = [];
    progresso = 0;
    acertos1 = 0;
    acertos2 = 0;
    fraseAcertada = false;

    criarPalavras();
    atualizarFrase();
    atualizarProgresso();
    atualizarPlacares();
}

// Fun√ß√£o para carregar o arquivo SRT de uma URL
async function loadSrtFromUrl(url) {
    let srtLoadedSuccessfully = false;
    try {
        showLoading(true);
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Failed to load SRT: ${response.status}`);
        }
        const srtContent = await response.text();

        // Processa o conte√∫do do SRT, populando o array 'frases'
        processSrtContent(srtContent);
        srtLoadedSuccessfully = true;

        // Esta √© a parte cr√≠tica: se o player de v√≠deo n√£o estiver pronto ap√≥s o carregamento do SRT,
        // o jogo deve iniciar no modo "apenas legendas".
        // A vari√°vel 'playerReady' √© controlada pelo evento 'loadedmetadata' do v√≠deo.
        if (!playerReady) {
            console.warn("V√≠deo n√£o est√° pronto. O jogo continuar√° usando apenas as legendas.");
            // Inicializa a interface do jogo sem a necessidade de reproduzir o v√≠deo.
            criarPalavras();
            atualizarFrase();
            atualizarProgresso();
    	    atualizarPlacares();
            // Garante que o monitor de tempo do v√≠deo n√£o seja iniciado.
            pararMonitorTempo();
        }

    } catch (error) {
        console.error("Erro ao carregar o arquivo SRT:", error);
        alert("Erro ao carregar o arquivo de legendas. O jogo continuar√° sem sincroniza√ß√£o de v√≠deo. Por favor, tente novamente mais tarde.");

        // Fallback robusto: se o SRT falhar, use uma frase gen√©rica para que o jogo n√£o pare.
        frases = [{
            tempoInicio: 0,
            tempoFim: 5,
            texto: "Aprenda a formar frases com pr√°tica di√°ria"
        }];

        // Re-inicializa o estado do jogo com a frase de fallback.
        indiceFrase = 0;
        fraseAtual = frases[indiceFrase];
        palavrasEmbaralhadas = embaralharPalavras(fraseAtual.texto);
        palavrasClicadas = [];
        progresso = 0;
        acertos1 = 0;
        acertos2 = 0;
        fraseAcertada = false;

        criarPalavras();
        atualizarFrase();
        atualizarProgresso();
        atualizarPlacares();
        document.getElementById('avancar').style.display = 'none';

        // Desativa explicitamente as funcionalidades de v√≠deo se o SRT falhou.
        if (videoElement) {
            videoElement.pause();
            videoElement.src = '';
            videoElement.load();
            playerReady = false;
        }
        pararMonitorTempo();
    } finally {
        showLoading(false); // Sempre esconde o indicador de carregamento.
    }

    // Ap√≥s tentar carregar o SRT, se ele foi bem-sucedido e o player est√° pronto,
    // o jogo pode tentar reproduzir o trecho.
    if (playerReady && fraseAtual && srtLoadedSuccessfully) {
        reproduzirTrechoAtual();
    }

    return srtLoadedSuccessfully; // Retorna true se o SRT foi carregado, false caso contr√°rio.
}
	
// Function to start a random player's clock
function startRandomPlayerClock() {
    // Stop both clocks first to ensure only one is running or both are reset
    if (player1Clock) player1Clock.stop();
    if (player2Clock) player2Clock.stop();

    // Randomly choose which player's clock to start
    const randomPlayer = Math.random();
    if (randomPlayer < 0.5) {
        if (player1Clock) player1Clock.start();
        console.log("Player 1's clock started.");
    } else {
        if (player2Clock) player2Clock.start();
        console.log("Player 2's clock started.");
    }
}
	
// Fun√ß√£o para carregar uma li√ß√£o
function loadLesson(lessonIndex, shouldRestoreProgress = false) {
    const allLessons = [...AppData.lessons.avulsas, ...AppData.lessons.trilha];
    const lesson = allLessons[lessonIndex];
    
    if (!lesson) {
        console.error("Li√ß√£o n√£o encontrada com o √≠ndice:", lessonIndex);
        return;
    }

    currentLessonName = lesson.name;
    document.getElementById('current-lesson').textContent = currentLessonName;

    // Configurar o v√≠deo
    videoElement.src = lesson.videoUrl;
    videoElement.load();

    let finalSrtUrl;
    if (lesson.srtFile && lesson.srtFile.startsWith('http')) {
        finalSrtUrl = lesson.srtFile;
    } else {
        finalSrtUrl = getSrtCdnUrl(lesson.srtFile);
    }

    // Carregar o arquivo SRT usando a URL final
    loadSrtFromUrl(finalSrtUrl).then(success => {
        if (success) {
            // VERIFICA E RESTAURA O PROGRESSO APENAS SE A FLAG shouldRestoreProgress ESTIVER ATIVA
            if (shouldRestoreProgress) {
                const progressoSalvo = carregarProgresso();
                // Verifique se o progresso salvo √© para a li√ß√£o correta e se o √≠ndice √© v√°lido
                if (progressoSalvo && progressoSalvo.lessonName === currentLessonName && progressoSalvo.fraseIndex < frases.length) {
                    indiceFrase = progressoSalvo.fraseIndex;
                    acertos1 = progressoSalvo.acertos1;
                    acertos2 = progressoSalvo.acertos2;
                    fraseAtual = frases[indiceFrase];
                    palavrasEmbaralhadas = embaralharPalavras(fraseAtual.texto);
                    palavrasClicadas = [];
                    fraseAcertada = false;
                    progresso = indiceFrase;
                    criarPalavras();
                    atualizarFrase();
                    atualizarProgresso();
                    atualizarPlacares();
                    console.log(`Progresso da li√ß√£o '${currentLessonName}' restaurado para a frase ${indiceFrase + 1}.`);
                } else {
                    // Se n√£o houver progresso v√°lido para restaurar, comece do zero
                    indiceFrase = 0;
                    acertos1 = 0;
                    acertos2 = 0;
                    progresso = 0;
                    palavrasEmbaralhadas = embaralharPalavras(fraseAtual.texto);
                    palavrasClicadas = [];
                    fraseAcertada = false;
                    criarPalavras();
                    atualizarFrase();
                    atualizarProgresso();
                    atualizarPlacares();
                    console.log("N√£o foi poss√≠vel restaurar o progresso. Iniciando a li√ß√£o do come√ßo.");
                }
            }
        }
        startRandomPlayerClock();
    });

    // Fechar o menu
    toggleMenu();

    // Salvar esta li√ß√£o como a √∫ltima acessada
    localStorage.setItem('lastLessonIndex', lessonIndex.toString());
}

// Fun√ß√£o para mostrar/esconder o indicador de carregamento
function showLoading(show) {
    const loadingElement = document.getElementById('loading');
    if (show) {
        loadingElement.classList.add('active');
    } else {
        loadingElement.classList.remove('active');
    }
}

// Fun√ß√£o para converter tempo de legenda para segundos
function converterTempo(tempo) {
    let partes = tempo.split(',');
    let segundos = partes[0].split(':');
    return parseInt(segundos[0]) * 3600 + parseInt(segundos[1]) * 60 + parseInt(segundos[2]) + parseInt(partes[1]) / 1000;
}

// Evento que ocorre quando o v√≠deo est√° pronto
videoElement.addEventListener('loadedmetadata', function() {
    playerReady = true;
    // Iniciar o jogo ap√≥s o v√≠deo estar pronto
    if (fraseAtual) {
        reproduzirTrechoAtual();
    }
});

// Fun√ß√£o para monitorar o tempo do v√≠deo
function iniciarMonitorTempo() {
    pararMonitorTempo(); // Clear any existing interval before starting a new one
    monitorTempoId = setInterval(() => {
        if (playerReady && fraseAtual) {
            let tempoAtual = videoElement.currentTime;
            if (tempoAtual >= fraseAtual.tempoFim) {
                videoElement.pause();
                pararMonitorTempo();
            }
        }
    }, 100);
}

// Fun√ß√£o para parar o monitor de tempo
function pararMonitorTempo() {
    if (monitorTempoId) {
        clearInterval(monitorTempoId);
        monitorTempoId = null;
    }
}

// Fun√ß√£o para embaralhar palavras
function embaralharPalavras(frase) {
    if (!frase) return [];
    let palavras = frase.split(' ');
    for (let i = palavras.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        let temp = palavras[i];
        palavras[i] = palavras[j];
        palavras[j] = temp;
    }
    return palavras;
}

// Fun√ß√£o para criar elementos de palavras
// Fun√ß√£o para criar elementos de palavras
function criarPalavras() {
    let palavrasDiv = document.getElementById('palavras');
    palavrasDiv.innerHTML = '';

    // Limpa o array global para a nova frase
    palavrasDisponiveisElementos = []; // <-- ADICIONE ESTA LINHA

    // ATUALIZA√á√ÉO AQUI: palavraElementos agora armazenar√° um array de elementos para cada palavra
    palavraElementos = {};

    if (!palavrasEmbaralhadas || palavrasEmbaralhadas.length === 0) return;

    palavrasEmbaralhadas.forEach(palavra => {
        let palavraDiv = document.createElement('div');
        palavraDiv.classList.add('palavra');
        palavraDiv.innerText = palavra;
        palavraDiv.onclick = () => clicarPalavra(palavra, palavraDiv);

        // Se a palavra ainda n√£o tem um array de elementos, crie um
        if (!palavraElementos[palavra]) {
            palavraElementos[palavra] = [];
        }
        // Adicione o elemento atual ao array correspondente √† palavra
        palavraElementos[palavra].push(palavraDiv);

        palavrasDiv.appendChild(palavraDiv);
        palavrasDisponiveisElementos.push(palavraDiv); // <-- ADICIONE ESTA LINHA
    });
}

// A vari√°vel global para armazenar TODOS os elementos DOM das palavras dispon√≠veis
// precisa ser inicializada e populada corretamente em 'criarPalavras'.
// Exemplo: let palavrasDisponiveisElementos = [];
// E em 'criarPalavras', para cada palavraDiv criada: palavrasDisponiveisElementos.push(palavraDiv);
// Certifique-se de que isso est√° no seu c√≥digo.

// Certifique-se de que 'palavrasDisponiveisElementos' est√° sendo populado corretamente
// na sua fun√ß√£o 'criarPalavras()' para lidar com elementos DOM espec√≠ficos.
function clicarPalavra(palavra, elemento) {
    if (!fraseAtual) return;

    if (elemento.classList.contains('acertada')) {
        return; // Ignora palavras j√° acertadas
    }

    const fraseSplit = fraseAtual.texto.split(' ');
    const proximaPalavraCorreta = fraseSplit[palavrasClicadas.length];
    const comprimentoFraseAtual = palavrasClicadas.length;

    // Cancela qualquer √°udio ou v√≠deo anterior antes de iniciar a pron√∫ncia da palavra clicada
    if (speechSynthesis.speaking) speechSynthesis.cancel();
    if (playerReady && !videoElement.paused) videoElement.pause();
    
    // Inicia a pron√∫ncia da palavra clicada
    const utterance = new SpeechSynthesisUtterance(palavra);
    utterance.lang = detectarIdioma(fraseAtual.texto);
    let currentUtterance = utterance; // Refer√™ncia para a utterance atual
    audioPlaying = true;
    
    // Define o que acontece quando a pron√∫ncia desta palavra terminar
    currentUtterance.onend = function() {
        audioPlaying = false; // Sinaliza que o √°udio terminou
        // Por padr√£o, se nada mais for encadeado, a a√ß√£o principal √© apenas a pron√∫ncia
        // Outras a√ß√µes (avan√ßar frase, trocar rel√≥gio) ser√£o definidas abaixo se houver encadeamento.
    };

    if (palavra === proximaPalavraCorreta) {
        // Palavra CORRETA!
        palavrasClicadas.push(palavra);
        elemento.classList.add('acertada');
        elemento.classList.remove('selecionada');
        
        const activeClockId = getActiveClockId();

        // Incrementa acertos (exceto a √∫ltima palavra, se auto-completa)
        if (comprimentoFraseAtual < fraseSplit.length - 1) {
            if (activeClockId === 'clock-face1') {
                acertos1++;
            } else if (activeClockId === 'clock-face2') {
                acertos2++;
            }
            atualizarPlacares();
        }
        
        atualizarFrase();
        switchActiveClock(); // Troca a vez ap√≥s o acerto

        // L√≥gica de Auto-Completa√ß√£o da √öltima Palavra e avan√ßo da frase
        if (comprimentoFraseAtual === fraseSplit.length - 2 && fraseSplit.length > 1) {
            const ultimaPalavra = fraseSplit[fraseSplit.length - 1];
            let elementoUltimaPalavraParaAutoEnviar = null;

            // Encontra e marca o elemento DOM da √∫ltima palavra
            if (palavrasDisponiveisElementos && palavrasDisponiveisElementos.length > 0) {
                 elementoUltimaPalavraParaAutoEnviar = palavrasDisponiveisElementos.find(el => 
                    el.innerText === ultimaPalavra && !el.classList.contains('acertada') && !palavrasClicadas.includes(ultimaPalavra)
                );
            }
            
            if (elementoUltimaPalavraParaAutoEnviar) {
                palavrasClicadas.push(ultimaPalavra);
                elementoUltimaPalavraParaAutoEnviar.classList.add('acertada');
                elementoUltimaPalavraParaAutoEnviar.classList.remove('selecionada');
                atualizarFrase();

                // Encadear pron√∫ncia da √∫ltima palavra ap√≥s a pen√∫ltima
                currentUtterance.onend = function() {
                    audioPlaying = false;
                    // Garante que n√£o h√° √°udios remanescentes antes da √∫ltima palavra
                    if (speechSynthesis.speaking) speechSynthesis.cancel(); 
                    if (playerReady && !videoElement.paused) videoElement.pause();

                    const utteranceUltima = new SpeechSynthesisUtterance(ultimaPalavra);
                    utteranceUltima.lang = detectarIdioma(fraseAtual.texto);
                    audioPlaying = true;
                    utteranceUltima.onend = function() {
                        audioPlaying = false;
                        processAndAdvancePhrase(); // Avan√ßa a frase ap√≥s a √∫ltima palavra
                    };
                    speechSynthesis.speak(utteranceUltima);
                };
            } else {
                 // Se n√£o encontrou o elemento para marcar, avan√ßa a frase ap√≥s a pron√∫ncia da palavra clicada
                currentUtterance.onend = function() {
                    audioPlaying = false;
                    processAndAdvancePhrase();
                };
            }
        }
        // Se a frase foi completada com o clique manual da √∫ltima palavra
        else if (palavrasClicadas.length === fraseSplit.length) {
            currentUtterance.onend = function() {
                audioPlaying = false;
                processAndAdvancePhrase(); // Avan√ßa a frase ap√≥s a pron√∫ncia
            };
        }

    } else { // Palavra INCORRETA!
        elemento.classList.add('errada');
        setTimeout(() => {
            elemento.classList.remove('errada');
        }, 500);
        
        currentUtterance.onend = function() {
            audioPlaying = false;
            switchActiveClock(); // Troca a vez ap√≥s a pron√∫ncia do erro
        };
    }

    // Inicia a pron√∫ncia da palavra clicada (esta √© a "primeira" pron√∫ncia no fluxo)
    speechSynthesis.speak(currentUtterance); 
}

function processAndAdvancePhrase() {
    // Stop both players' clocks immediately
    if (player1Clock) player1Clock.stop();
    if (player2Clock) player2Clock.stop();

    showLoading(true); // Show loading spinner

    progresso++; // Increment overall lesson progress
    atualizarProgresso();
    salvarProgresso(); // Save current game state

    setTimeout(() => {
        indiceFrase++; // Move to the next phrase
        if (indiceFrase >= frases.length) {
            alert("Parab√©ns! Voc√™ completou todas as frases!");
            indiceFrase = 0; // Reset to first phrase
            acertos1 = 0; // Reset player scores
            acertos2 = 0;
            progresso = 0; // Reset lesson progress
            salvarProgresso(); // Save reset state
        }
        fraseAtual = frases[indiceFrase]; // Get the new current phrase
        palavrasEmbaralhadas = embaralharPalavras(fraseAtual.texto); // Reshuffle words for new phrase
        palavrasClicadas = []; // Clear clicked words for new phrase
        fraseAcertada = false; // Reset phrase status
        criarPalavras(); // Generate new word elements
        mostrarTraducao = false; // Hide translation by default for new phrase
        atualizarFrase(); // Update phrase display (and subtitle)
        reproduzirTrechoAtual(); // Play the new phrase's video/audio
        showLoading(false); // Hide loading spinner
        atualizarPlacares(); // Update player score displays

        // Switch active player's clock for the new phrase, unless lesson is truly finished
        if (indiceFrase < frases.length) { // Check if there's actually a next phrase to play
            switchActiveClock();
        } else {
            console.log("Lesson completed, no more clocks to switch.");
        }
    }, 1500); // 1.5 second delay before loading the next phrase
}
	
// Fun√ß√£o para pausar todos os √°udios
function pausarAudios() {
    // Pausar o sintetizador de voz
    if (speechSynthesis.speaking) {
        speechSynthesis.cancel();
        audioPlaying = false;
    }

    // Pausar o v√≠deo se estiver tocando
    if (playerReady && !videoElement.paused) {
        videoElement.pause();
    }
}

// Fun√ß√£o para detectar o idioma com base no texto
function detectarIdioma(texto) {
    if (!texto) return 'en-US';

    // Esta √© uma detec√ß√£o simples
    if (texto.includes('Aku') || texto.includes('kamu')) {
        return 'id-ID'; // Indon√©sio
    } else if (texto.includes('Schei√üe')) {
        return 'de-DE'; // Alem√£o
    }
    return 'en-US'; // Por padr√£o, usamos ingl√™s
}

/*
 * API n√£o oficial, sem limite oficial
 * mas o uso √© feito por conta e risco.
 * Para uso pessoal e leve,
 * provavelmente n√£o haver√° problemas.
 */
function translateSrt(text) {
    return new Promise((resolve, reject) => {
        if (text.trim() === '') {
            resolve(''); // Resolve with empty string for empty input
            return;
        }

        const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=pt&dt=t&q=${encodeURI(text)}`;

        fetch(url)
            .then(response => response.json())
            .then(data => {
                let translation = '';
                data[0].forEach(item => {
                    translation += item[0];
                });
                resolve(translation);
            })
            .catch(error => {
                console.error('Erro na tradu√ß√£o:', error);
                reject(error); // Reject the promise on error
            });
    });
}

// Fun√ß√£o para atualizar a frase exibida
function atualizarFrase() {
    let fraseDiv = document.getElementById('frase');
    let subtitleContentDiv = document.getElementById('subtitle-content');
    fraseDiv.innerHTML = '';

    // Adiciona as palavras j√° clicadas com um espa√ßo entre elas
    palavrasClicadas.forEach((palavra) => {
        const span = document.createElement('span');
        span.textContent = palavra + ' ';
        span.classList.add('palavra-na-frase');
        fraseDiv.appendChild(span);
    });

    // Atualiza a div de conte√∫do da legenda com base no estado de 'mostrarTraducao'
    if (fraseAtual && subtitleContentDiv) {
        if (mostrarTraducao) {
            // Se 'mostrarTraducao' for true, busca e exibe a tradu√ß√£o
            translateSrt(fraseAtual.texto)
                .then(translatedText => {
                    subtitleContentDiv.textContent = translatedText;
                    subtitleContentDiv.classList.remove('hidden'); // Certifica-se de que est√° vis√≠vel
                })
                .catch(error => {
                    console.error('Erro na tradu√ß√£o:', error);
                    subtitleContentDiv.textContent = fraseAtual.texto; // Fallback para o original
                    subtitleContentDiv.classList.remove('hidden');
                });
        } else {
            // Se n√£o, oculta a legenda
            subtitleContentDiv.classList.add('hidden');
            subtitleContentDiv.textContent = ''; // Limpa o conte√∫do
        }
    } else if (subtitleContentDiv) {
        subtitleContentDiv.classList.add('hidden');
        subtitleContentDiv.textContent = ''; // Limpa o conte√∫do
    }
}

// REMOVIDA: A fun√ß√£o verificarFrase() foi removida e sua l√≥gica movida para o bot√£o "avancar".

// Fun√ß√£o para ler a frase atual usando o sintetizador de voz
function lerFraseAtual() {
    if (!fraseAtual) return;

    // Pausar qualquer √°udio em reprodu√ß√£o
    pausarAudios();

    const utterance = new SpeechSynthesisUtterance(fraseAtual.texto);
    utterance.lang = detectarIdioma(fraseAtual.texto);

    // Configurar flag para controlar √°udio
    audioPlaying = true;
    utterance.onend = function() {
        audioPlaying = false;
    };

    speechSynthesis.speak(utterance);
}

// Fun√ß√£o para atualizar o progresso
function atualizarProgresso() {
    document.getElementById('progresso').innerText = `Progresso: ${progresso} de ${frases.length}`;
}

// Nova fun√ß√£o para atualizar ambos os placares, ou as fun√ß√µes separadas
function atualizarPlacares() {
    document.getElementById('placar1').innerText = ` ${acertos1}`;
    document.getElementById('placar2').innerText = ` ${acertos2}`;
}

// Fun√ß√£o para reproduzir o trecho do v√≠deo atual
function reproduzirTrechoAtual() {
    if (!fraseAtual) return;

    // Pausar qualquer √°udio em reprodu√ß√£o
    pausarAudios();

    // Apenas tente reproduzir o v√≠deo se o player estiver pronto.
    if (playerReady) {
        videoElement.currentTime = fraseAtual.tempoInicio;
        videoElement.play();
        iniciarMonitorTempo();
    } else {
        // Se o player n√£o estiver pronto, apenas leia a frase.
        // Isso √© crucial para o modo "apenas legendas".
        console.log("Player n√£o est√° pronto. Lendo a frase em vez de reproduzir o v√≠deo.");
        lerFraseAtual();
    }
}

// Fun√ß√£o para esconder todos os itens internos do menu e o cabe√ßalho
function hideMenuContent() {
    // Esconde o cont√™iner de sele√ß√£o de modo
    const menuMode = document.getElementById('menu-mode');
    if (menuMode) {
        menuMode.style.display = 'none';
    }

    // Esconde o cont√™iner de lista de li√ß√µes
    const menuItems = document.getElementById('menu-items');
    if (menuItems) {
        menuItems.style.display = 'none';
    }
}

// Fun√ß√£o para restaurar a exibi√ß√£o do menu
function restoreMenuContent() {
¬† ¬† // Mostra o cabe√ßalho do menu
¬† ¬† const menuHeader = document.getElementById('menu-header');
¬† ¬† if (menuHeader) {
¬† ¬† ¬† ¬† menuHeader.style.display = 'flex';
¬† ¬† }

¬† ¬† // Restaura o estado anterior do menu
¬† ¬† switch(previousMenuState) {
¬† ¬† ¬† ¬† case "modeSelection":
¬† ¬† ¬† ¬† ¬† ¬† document.getElementById('menu-mode').style.display = 'block';
¬† ¬† ¬† ¬† ¬† ¬† break;
¬† ¬† ¬† ¬† case "lessonList":
¬† ¬† ¬† ¬† ¬† ¬† document.getElementById('menu-items').style.display = 'block';
¬† ¬† ¬† ¬† ¬† ¬† break;
¬† ¬† }
}

// Fun√ß√£o para inicializar o estado do menu
function initializeMenu() {
    menuStack = ["modeSelection"];
    currentState = "modeSelection";
    updateMenuDisplay();
}

// Onde a l√≥gica de esconder tudo √© centralizada e reutiliz√°vel
function toggleMenu() {
    const menuButton = document.getElementById('menu-button');
    const menuOverlay = document.getElementById('menu-overlay');
    menuButton.classList.toggle('active');
    menuOverlay.classList.toggle('active');

    // Ao fechar o menu, chame a fun√ß√£o para resetar a exibi√ß√£o
    if (!menuOverlay.classList.contains('active')) {
        hideMenuContent();
    }
    // Ao abrir, ainda pode usar sua l√≥gica de inicializa√ß√£o
    if (menuOverlay.classList.contains('active')) {
        initializeMenu();
    }
}

function showLessonsList() {
    document.getElementById('menu-mode').style.display = 'none';    
    document.getElementById('menu-items').style.display = 'block';
    document.getElementById('menu-header').style.display = 'flex';  
    document.getElementById('menu-footer').style.display = 'flex';
}

// Fun√ß√£o para alternar a exibi√ß√£o da selecao de modo
function currentMode(mode) {
    if (mode === 'solo') {
        showLessonsList();
        pushMenuState("lessonList");
    } else if (mode === 'multi') {
        alert("Modo multiplayer em desenvolvimento");
    }
}

// Mostrar e esconder o card
const continueCard = document.getElementById('continue-card');
const continueLessonName = document.getElementById('continue-lesson-name');
const continueProgress = document.getElementById('continue-progress');
const continueButton = document.getElementById('continue-button');

function showContinueCard() {
    continueCard.classList.remove('hidden');
}

function hideContinueCard() {
    continueCard.classList.add('hidden');
}

// Inicializar bot√µes das li√ß√µes
function initializeMenuButtons() {
    // Seleciona o cont√™iner espec√≠fico para a lista de li√ß√µes
    const lessonsListContainer = document.getElementById('lessons-list');
    
    // Limpa apenas a lista de li√ß√µes, preservando o resto do menu-items (como o footer)
    lessonsListContainer.innerHTML = '';

    // Combina todas as li√ß√µes em uma √∫nica lista
    const allLessons = [...AppData.lessons.avulsas, ...AppData.lessons.trilha];

    allLessons.forEach((lesson, index) => {
        const button = document.createElement('button');
        button.textContent = lesson.name;
        button.classList.add('lesson-button');
        // O onclick agora passa o √≠ndice global da lista combinada
        button.onclick = () => loadLesson(index);
        lessonsListContainer.appendChild(button); // Adiciona o bot√£o ao cont√™iner da lista
    });
}

// --- Event Listeners ---
document.querySelector('.back-button').onclick = function() {
    const canGoBack = popMenuState();
    // Apenas fecha o menu se N√ÉO conseguir voltar (ou seja, j√° est√° no estado inicial)
    if (!canGoBack) {
        toggleMenu();
    }
};

// --- NOVO: L√≥gica do bot√£o "Desistir" (Passar) ---
document.getElementById('desistir').onclick = function() {
    if (!fraseAtual) return;

    const fraseSplit = fraseAtual.texto.split(' ');
    // A palavra correta que esperamos na posi√ß√£o atual da frase
    const palavraCorretaAtual = fraseSplit[palavrasClicadas.length];

    // Se n√£o houver mais palavras para revelar (frase j√° completa de alguma forma), apenas retorne.
    if (!palavraCorretaAtual) {
        console.warn("Nenhuma palavra para revelar. Frase j√° completa ou n√£o inicializada.");
        return;
    }

    // Remove destaque de qualquer palavra selecionada anteriormente
    const palavraSelecionadaAnteriormente = document.querySelector('.palavra.selecionada');
    if (palavraSelecionadaAnteriormente) {
        palavraSelecionadaAnteriormente.classList.remove('selecionada');
    }

    let elementoCorretoParaAcertar = null;
    // Encontra o elemento DOM da palavra a ser revelada
    if (palavraElementos[palavraCorretaAtual]) {
        elementoCorretoParaAcertar = palavraElementos[palavraCorretaAtual].find(el => !el.classList.contains('acertada'));
    }

    if (elementoCorretoParaAcertar) {
        // Adiciona a palavra correta √† frase constru√≠da
        palavrasClicadas.push(palavraCorretaAtual);
        // Marca o elemento DOM como acertado
        elementoCorretoParaAcertar.classList.add('acertada');
        elementoCorretoParaAcertar.classList.remove('selecionada'); // Remove qualquer resqu√≠cio de 'selecionada'
        
        atualizarFrase(); // Atualiza a exibi√ß√£o da frase

        progresso++; // Incrementa progresso da li√ß√£o
        atualizarProgresso();
        salvarProgresso(); // Salva o progresso

        // Cancela qualquer √°udio ou v√≠deo anterior antes de pronunciar a palavra revelada
        if (speechSynthesis.speaking) speechSynthesis.cancel();
        if (playerReady && !videoElement.paused) videoElement.pause();

        // Inicia a pron√∫ncia da palavra que acabou de ser revelada
        const utteranceRevelada = new SpeechSynthesisUtterance(palavraCorretaAtual);
        utteranceRevelada.lang = detectarIdioma(fraseAtual.texto);
        audioPlaying = true; // Sinaliza que √°udio est√° tocando
        
        // Verifica se a frase est√° completa AP√ìS a revela√ß√£o desta palavra
        const isFraseCompleta = palavrasClicadas.length === fraseSplit.length;
        const isPenultimaPalavra = palavrasClicadas.length === fraseSplit.length - 1 && fraseSplit.length > 1;

        if (isPenultimaPalavra) {
            const ultimaPalavra = fraseSplit[fraseSplit.length - 1];
            let elementoUltimaPalavraParaAutoEnviar = null;

            // Encontra e marca o elemento DOM da √∫ltima palavra
            if (palavrasDisponiveisElementos && palavrasDisponiveisElementos.length > 0) {
                 elementoUltimaPalavraParaAutoEnviar = palavrasDisponiveisElementos.find(el => 
                    el.innerText === ultimaPalavra && !el.classList.contains('acertada') && !palavrasClicadas.includes(ultimaPalavra)
                );
            }
            
            if (elementoUltimaPalavraParaAutoEnviar) {
                // Adiciona a √∫ltima palavra √† sequ√™ncia (auto-completando)
                palavrasClicadas.push(ultimaPalavra);
                elementoUltimaPalavraParaAutoEnviar.classList.add('acertada');
                elementoUltimaPalavraParaAutoEnviar.classList.remove('selecionada');
                atualizarFrase(); // Atualiza a exibi√ß√£o com a √∫ltima palavra
            }

            // Encadear a pron√∫ncia da √∫ltima palavra ap√≥s a pron√∫ncia da pen√∫ltima revelada
            utteranceRevelada.onend = function() {
                audioPlaying = false; // Pron√∫ncia da pen√∫ltima terminou
                // Garante que n√£o h√° √°udios remanescentes antes da √∫ltima palavra
                if (speechSynthesis.speaking) speechSynthesis.cancel(); 
                if (playerReady && !videoElement.paused) videoElement.pause();

                const utteranceUltima = new SpeechSynthesisUtterance(ultimaPalavra);
                utteranceUltima.lang = detectarIdioma(fraseAtual.texto);
                audioPlaying = true;
                utteranceUltima.onend = function() {
                    audioPlaying = false; // Pron√∫ncia da √∫ltima terminou
                    processAndAdvancePhrase(); // Avan√ßa a frase
                };
                speechSynthesis.speak(utteranceUltima);
            };

        } else if (isFraseCompleta) {
            // Se a frase foi completada pela revela√ß√£o desta palavra (e n√£o era a pen√∫ltima)
            utteranceRevelada.onend = function() {
                audioPlaying = false; // Pron√∫ncia terminou
                processAndAdvancePhrase(); // Avan√ßa a frase
            };
        } else {
            // Se a frase N√ÉO foi completada, apenas troca a vez ap√≥s a pron√∫ncia
            utteranceRevelada.onend = function() {
                audioPlaying = false; // Pron√∫ncia terminou
                switchActiveClock(); // Troca a vez
            };
        }

        speechSynthesis.speak(utteranceRevelada); // Dispara a pron√∫ncia da palavra revelada
    } else {
        console.warn("Nenhuma ocorr√™ncia n√£o acertada da palavra encontrada para 'Passar':", palavraCorretaAtual);
        // Se, por algum motivo, n√£o encontrou a palavra para revelar,
        // ainda queremos trocar o rel√≥gio para n√£o travar o jogo.
        switchActiveClock();
    }
};

document.getElementById('repetir').onclick = function() {
    reproduzirTrechoAtual();
};

document.getElementById('lerFrase').onclick = function() {
    lerFraseAtual();
};

document.getElementById('menu-button').onclick = toggleMenu;

// NOVO LISTENER: Adiciona a funcionalidade para o bot√£o de tradu√ß√£o
document.getElementById('traduzir-btn').onclick = function() {
    // Alterna o estado da vari√°vel
    mostrarTraducao = !mostrarTraducao;
    // Atualiza a interface para exibir ou ocultar a legenda
    atualizarFrase();
};

// Adicionar um listener para o evento de erro do v√≠deo
videoElement.addEventListener('error', function(e) {
    console.error("Erro ao carregar o v√≠deo. O jogo continuar√° sem sincroniza√ß√£o com o v√≠deo.", e);
    playerReady = false; // Garante que a flag seja false em caso de erro
    // Voc√™ pode mostrar uma mensagem para o usu√°rio aqui
    alert("Ocorreu um erro ao carregar o v√≠deo. O jogo continuar√° no modo texto.");
    pararMonitorTempo();
});


// Fun√ß√£o para criar o Clock
function createClock(clockFaceId) {
    const clockFace = document.getElementById(clockFaceId);
    let currentProgress = 0;
    const totalTimeMs = 10000; // 10 segundos
    const updateIntervalMs = 16;
    const steps = totalTimeMs / updateIntervalMs;
    const progressPerStep = 100 / steps;

    // Define o ponto percentual onde os cliques ser√£o desabilitados
    const disableClickThreshold = 90; // Desabilita quando 80% do tempo se foi (20% restantes)

    let intervalId;
    let _isActive = false;

    function updateClock() {
        if (currentProgress <= 100) {
            clockFace.style.setProperty('--progress', currentProgress);

            const percentageRemaining = 100 - currentProgress;

            // L√≥gica para piscar o clock (j√° existente)
            if (percentageRemaining <= 40 && percentageRemaining > 0) {
                clockFace.classList.add('time-almost-up');
            } else {
                clockFace.classList.remove('time-almost-up');
            }

            // L√≥gica para desabilitar cliques nas palavras
            if (currentProgress >= disableClickThreshold && _isActive) {
                // Adiciona a classe 'no-click' a todas as palavras se o tempo estiver acabando
                document.querySelectorAll('.palavra').forEach(p => p.classList.add('no-click'));
            } else {
                // Garante que a classe seja removida se o tempo voltou ao normal (ex: turno de outro jogador)
                document.querySelectorAll('.palavra').forEach(p => p.classList.remove('no-click'));
            }

            currentProgress += progressPerStep;
        } else {
            // Clock completou, para e chama o switch automaticamente
            stopClock(true);
            console.log(`Clock '${clockFaceId}' fill complete!`);
        }
    }

    function startClock() {
        currentProgress = 0;
        clockFace.classList.remove('time-almost-up');
        // NOVO: Habilita os cliques nas palavras ao iniciar o turno
        document.querySelectorAll('.palavra').forEach(p => p.classList.remove('no-click'));
        intervalId = setInterval(updateClock, updateIntervalMs);
        _isActive = true;
    }

    function stopClock(autoSwitch = false) {
        clearInterval(intervalId);
        clockFace.classList.remove('time-almost-up');
        // Garante que os cliques sejam reativados quando o clock para (importante se o jogo pausa ou muda de fase)
        // No entanto, se o pr√≥ximo clock for iniciar, ele vai reativar.
        // A l√≥gica principal de desabilitar/reabilitar est√° no updateClock e startClock.
        // Opcional: document.querySelectorAll('.palavra').forEach(p => p.classList.remove('no-click'));
        
        // Se n√£o foi por conclus√£o (parada manual), reseta o progresso visualmente
        if (!autoSwitch) {
            currentProgress = 0;
            clockFace.style.setProperty('--progress', currentProgress);
        }
        
        _isActive = false;
        
        if (autoSwitch) {
            setTimeout(() => {
                switchStoppedClock(clockFaceId);
            }, 100);
        }
    }

    function isActive() {
        return _isActive;
    }

    return {
        start: startClock,
        stop: stopClock,
        isActive: isActive
    };
}
	
function switchStoppedClock(currentClockId) {
    if (currentClockId === 'clock-face1') {
        player2Clock.start();
        console.log('Clock 1 finished, starting Clock 2');
    } else if (currentClockId === 'clock-face2') {
        player1Clock.start();
        console.log('Clock 2 finished, starting Clock 1');
    }
}

function getActiveClockId() {
    if (player1Clock && player1Clock.isActive()) {
        return 'clock-face1';
    }
    if (player2Clock && player2Clock.isActive()) {
        return 'clock-face2';
    }
    return null;
}

function switchActiveClock() {
    const activeClockId = getActiveClockId();

    if (activeClockId === 'clock-face1') {
        player1Clock.stop();
        player2Clock.start();
        console.log('Switched from Player 1 clock to Player 2 clock.');
    } else if (activeClockId === 'clock-face2') {
        player2Clock.stop();
        player1Clock.start();
        console.log('Switched from Player 2 clock to Player 1 clock.');
    } else {
        player1Clock.start();
        console.log('No active clock found, starting Player 1 clock.');
    }
}

// *** Inicializar a aplica√ß√£o *** //
function init() {
    initializeMenu();
    initializeMenuButtons();
	  checkAuthStatus();
    
    // Initialize clocks
    player1Clock = createClock('clock-face1');
    player2Clock = createClock('clock-face2');

    // Mostrar inicialmente a mensagem para selecionar uma li√ß√£o
    document.getElementById('current-lesson').textContent = "Selecione uma li√ß√£o";

    // Combina todas as li√ß√µes para verifica√ß√£o
    const allLessons = [...AppData.lessons.avulsas, ...AppData.lessons.trilha];

    // Verificar se h√° algum par√¢metro na URL para carregar uma li√ß√£o espec√≠fica
    const urlParams = new URLSearchParams(window.location.search);
    const lessonParam = urlParams.get('lesson');

    if (lessonParam !== null && !isNaN(lessonParam) && parseInt(lessonParam) < allLessons.length) {
        // Carregar a li√ß√£o especificada pelo par√¢metro da URL
        loadLesson(parseInt(lessonParam));
    } else {
        // Se n√£o houver par√¢metro, abrir o menu automaticamente
        setTimeout(() => {
            toggleMenu();
        }, 500);
    }

    // Adicionar listener para teclas de atalho
    document.addEventListener('keydown', function(event) {
        // Tecla ESC para fechar ou abrir o menu
        if (event.key === 'Escape') {
            const menuOverlay = document.getElementById('menu-overlay');
            if (menuOverlay.classList.contains('active')) {
                toggleMenu();
            }
        }

        // Tecla ESPA√áO para reproduzir/pausar o trecho atual
        if (event.code === 'Space' && !event.target.matches('input, textarea')) {
            event.preventDefault();
            if (playerReady && videoElement.paused) {
                reproduzirTrechoAtual();
            } else {
                videoElement.pause();
                pararMonitorTempo();
            }
        }

        // Tecla ENTER para avan√ßar quando dispon√≠vel
        if (event.key === 'Enter') {
            const avancarBtn = document.getElementById('avancar');
            if (avancarBtn.style.display !== 'none') {
                avancarBtn.click();
            }
        }
    });

    // Adicionar evento para restaurar a interface quando o v√≠deo terminar
    videoElement.addEventListener('ended', function() {
        pararMonitorTempo();
    });

    // Verificar se h√° uma √∫ltima li√ß√£o acessada e progresso salvo
    // A sua l√≥gica original de verifica√ß√£o de progresso
    const lastLessonIndex = localStorage.getItem('lastLessonIndex');
    const progressoSalvo = carregarProgresso();
    
¬† ¬† // A sua l√≥gica de verifica√ß√£o
¬† ¬† if (lastLessonIndex !== null && !isNaN(lastLessonIndex) && parseInt(lastLessonIndex) < allLessons.length) {
¬† ¬† ¬† ¬† const lesson = allLessons[parseInt(lastLessonIndex)];
¬† ¬† ¬† ¬† // Supondo que 'frases' esteja dentro do objeto da li√ß√£o
¬† ¬† ¬† ¬† // √â melhor obter a lista de frases ap√≥s carregar o SRT para evitar erros,
¬† ¬† ¬† ¬† // ent√£o vamos remover essa linha ou deix√°-la comentada.
¬† ¬† ¬† ¬† // const frases = lesson.frases;

¬† ¬† ¬† ¬† // Preenche os dados do card
¬† ¬† ¬† ¬† continueLessonName.textContent = lesson.name;

¬† ¬† ¬† ¬† const progressoSalvo = carregarProgresso();

¬† ¬† ¬† ¬† if (progressoSalvo && progressoSalvo.lessonName === lesson.name) {
¬† ¬† ¬† ¬† ¬† ¬† continueProgress.textContent = `Frase ${progressoSalvo.fraseIndex + 1}`; // Removido o 'de ${frases.length}' pois a lista ainda n√£o est√° carregada.
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† continueProgress.textContent = `Iniciar li√ß√£o`;
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† // Mostra o card de continuar
¬† ¬† ¬† ¬† showContinueCard();

¬† ¬† ¬† ¬† // Adiciona um listener de evento ao bot√£o "Continuar"
¬† ¬† ¬† ¬† // Apenas chame a loadLesson com a flag de restaura√ß√£o
¬† ¬† ¬† ¬† continueButton.onclick = () => {
¬† ¬† ¬† ¬† ¬† ¬† loadLesson(parseInt(lastLessonIndex), true); // <--- AQUI EST√Å A MUDAN√áA PRINCIPAL
¬† ¬† ¬† ¬† ¬† ¬† hideContinueCard();
¬† ¬† ¬† ¬† };

¬† ¬† } else {
¬† ¬† ¬† ¬† // Se n√£o houver progresso, garanta que o card est√° escondido
¬† ¬† ¬† ¬† hideContinueCard();
¬† ¬† }
}

// Inicializar a aplica√ß√£o quando o DOM estiver carregado
document.addEventListener('DOMContentLoaded', init);
		</script>
	</body>
</html>
